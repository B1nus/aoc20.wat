(component
  (core module $main
    (import "deps" "memory" (memory 1))
    (import "deps" "realloc" (func $realloc (param i32 i32 i32 i32) (result i32)))
    (import "std" "output" (func $output (param i32 i32)))
    (import "std" "input" (func $input (result i32 i32)))
    (import "std" "u32.format" (func $"u32.format" (param i32) (result i32 i32)))
    (import "std" "list u8.add" (func $"list u8.add" (param i32 i32 i32) (result i32 i32)))
    (import "std" "list u8.join" (func $"list u8.join" (param i32 i32 i32 i32) (result i32 i32)))
    (func $readInput (param $count i32) (result i32 i32)
      (local $ptr i32)
      (local $len i32)
      (call $input)
      (local.set $len)
      (local.set $ptr)
      (loop $read
        (local.set $count (i32.sub (local.get $count) (i32.const 1)))
        (if (i32.gt_s (local.get $count) (i32.const 0))
          (then
            (local.get $ptr)
            (local.get $len)
            (call $input)
            (call $"list u8.join")
            (local.set $len)
            (local.set $ptr)
            (br $read)
          )
        )
      )
      (local.get $ptr)
      (local.get $len)
    )
    (func $main
      (local $x i32)
      (local $y i32)
      (local $index i32)
      (local $count i32)
      (local $width i32)
      (local $ptr i32)
      (local $len i32)
      (call $readInput (i32.const 12))
      (local.set $len)
      (local.set $ptr)
      (local.set $width (i32.add
        (call $"list u8.find"
          (local.get $ptr)
          (local.get $len)
          (i32.const 10)
        )
        (i32.const 1)
      ))
      (loop $move
        (local.set $x (i32.rem_u
          (i32.add
            (local.get $x)
            (i32.const 3)
          )
          (i32.sub
            (local.get $width)
            (i32.const 1)
          )
        ))
        (local.set $y (i32.add (local.get $y) (i32.const 1)))
        (local.set $index (i32.add
          (i32.mul
            (local.get $width)
            (local.get $y)
          )
          (local.get $x)
        ))
        (if (i32.eq (i32.load8_u (i32.add (local.get $ptr) (local.get $index))) (i32.const 35))
          (then
            (local.set $count (i32.add (local.get $count) (i32.const 1)))
          )
        )
        (br_if $move (i32.lt_u (local.get $index) (local.get $len)))
      )
      (call $"u32.format" (local.get $count))
      (call $"list u8.add" (i32.const 10))
      (call $output)
    )
    (func $"list u8.find" (param $ptr i32) (param $len i32) (param $byte i32) (result i32)
      (local $max i32)
      (local.set $max (i32.add (local.get $ptr) (local.get $len)))
      (loop $loop
        (if (i32.eq (i32.load8_u (local.get $ptr)) (local.get $byte))
          (then
            (return (i32.sub (local.get $ptr) (i32.sub (local.get $max) (local.get $len))))
          )
        )
        (local.set $ptr (i32.add (local.get $ptr) (i32.const 1)))
        (br_if $loop (i32.lt_u (local.get $ptr) (local.get $max)))
      )
      (unreachable)
    )
    (func (export "run") (result i32)
      (call $main)
      (i32.const 0)
    )
  )

  (core module $std
    (import "deps" "realloc" (func $realloc (param i32 i32 i32 i32) (result i32)))
    (import "deps" "memory" (memory 1))
    (import "wasi" "[method]output-stream.blocking-write-and-flush" (func $"[method]output-stream.blocking-write-and-flush" (param i32 i32 i32 i32)))
    (import "wasi" "[method]input-stream.blocking-read" (func $"[method]input-stream.blocking-read" (param i32 i64 i32)))
    (import "wasi" "get-stdout" (func $get-stdout (result i32)))
    (import "wasi" "get-stdin" (func $get-stdin (result i32)))
    (memory (export "mem") 1)
    (func (export "output") (param $ptr i32) (param $len i32)
      (call $"[method]output-stream.blocking-write-and-flush"
        (call $get-stdout)
        (local.get $ptr)
        (local.get $len)
        (call $realloc (i32.const 0) (i32.const 8) (i32.const 4) (i32.const 0))
      )
    )
    (func (export "list u8.join") (param $ptr i32) (param $len i32) (param $other_ptr i32) (param $other_len i32) (result i32 i32)
      (local $new_ptr i32)
      (local $new_len i32)
      (local.set $new_len (i32.add (local.get $len) (local.get $other_len)))
      (local.set $new_ptr (call $realloc (i32.const 0) (local.get $new_len) (i32.const 4) (i32.const 0)))
      (memory.fill (local.get $new_ptr) (i32.const 0x30) (local.get $new_len))
      (memory.copy (i32.const 0) (local.get $new_ptr) (local.get $ptr) (local.get $len))
      (memory.copy (i32.const 0) (i32.add (local.get $new_ptr) (local.get $len)) (local.get $other_ptr) (local.get $other_len))
      (drop)
      (drop)
      (local.get $new_ptr)
      (local.get $new_len)
    )
    (func (export "list u8.add") (param $ptr i32) (param $len i32) (param $byte i32) (result i32 i32)
      (local $mem i32)
      (local.set $mem (local.get $ptr))
      (local.set $ptr (call $realloc (local.get $ptr) (i32.add (local.get $len) (i32.const 1)) (i32.const 4) (i32.const 0)))
      (memory.copy (i32.const 0) (local.get $ptr) (local.get $mem) (local.get $len))
      (drop)
      (i32.store8 (i32.add (local.get $ptr) (local.get $len)) (local.get $byte))
      (local.get $ptr)
      (i32.add (local.get $len) (i32.const 1))
    )
    (func (export "u32.format") (param $number i32) (result i32 i32)
      (local $len i32)
      (local $num i32)
      (local $ptr i32)
      (local $i i32)
      (local.set $num (local.get $number))
      (loop $len
        (local.set $len (i32.add (local.get $len) (i32.const 1)))
        (local.set $num (i32.div_u (local.get $num) (i32.const 10)))
        (br_if $len (i32.gt_u (local.get $num) (i32.const 0)))
      )

      (local.set $ptr (call $realloc (i32.const 0) (local.get $len) (i32.const 4) (i32.const 0)))
      (loop $store
        (local.set $i (i32.add (local.get $i) (i32.const 1)))
        (i32.store8 (i32.sub (i32.add (local.get $ptr) (local.get $len)) (local.get $i)) (i32.add (i32.rem_u (local.get $number) (i32.const 10)) (i32.const 48)))
        (local.set $number (i32.div_u (local.get $number) (i32.const 10)))
        (br_if $store (i32.gt_u (local.get $number) (i32.const 0)))
      )
    
      (local.get $ptr)
      (local.get $len)
    )
    (func (export "input") (result i32 i32)
      (local $ptr i32)
      (local $len i32)
      (local.set $ptr (call $realloc (i32.const 0) (i32.const 12) (i32.const 4) (i32.const 0)))
      (call $"[method]input-stream.blocking-read" 
        (call $get-stdin)
        (i64.const 0x1000)
        (local.get $ptr)
      )
      (local.set $len (i32.load (i32.add (local.get $ptr) (i32.const 8))))
      (local.set $ptr (i32.load (i32.add (local.get $ptr) (i32.const 4))))
      (call $realloc (local.get $ptr) (local.get $len) (i32.const 4) (i32.const 0))
      (local.get $len)
    )
  )

  (core module $deps
    (memory (export "memory") 1)
    (global $ptr (mut i32) (i32.const 0))
    (; Bump Allocator. Thanks Bryan Burgers: https://burgers.io/complete-novice-wasm-allocator ;)
    (func (export "realloc") (param i32) (param $len i32) (param $alignment i32) (param i32) (result i32)
      (local $ptr i32)
      (local $rem i32)
      (local.set $ptr (global.get $ptr))
      (global.set $ptr (i32.add (global.get $ptr) (local.get $len)))
      (local.set $rem (i32.rem_u (global.get $ptr) (local.get $alignment)))
      (if (local.get $rem)
        (then
          (global.set $ptr (i32.add (global.get $ptr) (i32.sub (local.get $alignment) (local.get $rem))))
        )
      )
      (if (i32.ge_u (global.get $ptr) (i32.mul (memory.size) (i32.const 0x10000)))
        (then
          (memory.grow (i32.add (i32.sub (i32.div_u (global.get $ptr) (i32.const 0x10000)) (memory.size)) (i32.const 1)))
          (drop)
        )
      )
      (local.get $ptr)
    )
  )

  (; Wasi imports ;)
  (import "wasi:io/error@0.2.3" (instance $error
    (export "error" (type (sub resource)))
  ))
  (alias export $error "error" (type $error))
  (import "wasi:io/streams@0.2.3" (instance $streams
    (export $input-stream "input-stream" (type (sub resource)))
    (export $output-stream "output-stream" (type (sub resource)))
    (alias outer 1 $error (type $error))
    (type $stream-errors (variant
      (case "last-operation-failed" (own $error))
      (case "closed")
    ))
    (export $stream-error "stream-error" (type (eq $stream-errors)))
    (export "[method]output-stream.blocking-write-and-flush" (func
      (param "self" (borrow $output-stream))
      (param "contents" (list u8))
      (result (result (error $stream-error)))
    ))
    (export "[method]input-stream.blocking-read" (func
      (param "self" (borrow $input-stream))
      (param "len" u64)
      (result (result (list u8) (error $stream-error)))
    ))
  ))
  (alias export $streams "output-stream" (type $output-stream))
  (alias export $streams "input-stream" (type $input-stream))
  (import "wasi:cli/stdout@0.2.3" (instance $stdout
    (alias outer 1 $output-stream (type $output-stream-t))
    (export $eq-output-stream "output-stream" (type (eq $output-stream-t)))
    (export "get-stdout" (func (result (own $eq-output-stream))))
  ))
  (import "wasi:cli/stdin@0.2.3" (instance $stdin
      (alias outer 1 $input-stream (type $input-stream))
      (export $eq-input-stream "input-stream" (type (eq $input-stream)))
      (export "get-stdin" (func (result (own $eq-input-stream))))
  ))
  
  (; Wasi aliases ;)
  (core instance $deps (instantiate $deps))
  (core func $"[method]output-stream.blocking-write-and-flush" (canon lower
    (func $streams "[method]output-stream.blocking-write-and-flush")
    (memory $deps "memory")
    (realloc (func $deps "realloc"))
  ))
  (core func $"[method]input-stream.blocking-read" (canon lower
    (func $streams "[method]input-stream.blocking-read")
    (memory $deps "memory")
    (realloc (func $deps "realloc"))
  ))
  (core func $get-stdout (canon lower (func $stdout "get-stdout")))
  (core func $get-stdin (canon lower (func $stdin "get-stdin")))

  (; Instantiation of modules ;)
  (core instance $std (instantiate $std
    (with "deps" (instance
      (export "memory" (memory $deps "memory"))
      (export "realloc" (func $deps "realloc"))
    ))
    (with "wasi" (instance
      (export "[method]output-stream.blocking-write-and-flush" (func $"[method]output-stream.blocking-write-and-flush"))
      (export "[method]input-stream.blocking-read" (func $"[method]input-stream.blocking-read"))
      (export "get-stdout" (func $get-stdout))
      (export "get-stdin" (func $get-stdin))
    ))
  ))
  (core instance $main (instantiate $main
    (with "deps" (instance
      (export "memory" (memory $deps "memory"))
      (export "realloc" (func $deps "realloc"))
    ))
    (with "std" (instance
      (export "output" (func $std "output"))
      (export "input" (func $std "input"))
      (export "u32.format" (func $std "u32.format"))
      (export "list u8.add" (func $std "list u8.add"))
      (export "list u8.join" (func $std "list u8.join"))
    ))
  ))

  (; Exporting main function ;)
  (func $run (result (result)) (canon lift (core func $main "run")))
  (component $cli
    (import "run" (func $run (result (result))))
    (export "run" (func $run))
  )
  (instance $cli (instantiate $cli (with "run" (func $run))))
  (export "wasi:cli/run@0.2.0" (instance $cli))
)
